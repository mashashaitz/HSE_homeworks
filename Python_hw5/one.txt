Python

Компилляция (си) - перевод нашего кода на язык компьютера (+1 лишний файл, работает быстрее)
Интерпретация (питон) - стразу кормим компу (можно исполнять по команде, не надо писать сразу прогу целиком)

Языки высокого и нижнего уровня (комп внизу, человек вверху; чем ближе к людям, тем выше)

Интегрированная среда разработки

Ошибка: 	
Не дает запустить, красная строка - ошибка синтаксиса
Очень часто делим на ноль или ещё как-то косячим - красное сообщение в шелле

Оператор = знак
+
“-“
“*”
“/” - реальное деление
“%” - остаток от деления
“//” - целочисленное деление (ответ сокращает до меньшего)
“=” - присвоить
“+=” - прибавить 1
“-=” - отнять 1
“**” - возведение в степень

Переменные
- Латинские буквы и цифры и подчеркивание (нижнее)
- не нужно начинать с цифры и подчеркивания
- не должны совпадать с уже встроенными переменными питона (и словами)
- ОСМЫСЛЕННЫЕ НАЗВАНИЯ
- надо объявлять

Int - число
Str - строка
Float - число с плавающей точкой

Функции 
Type() - определяем тип
Print() - выводим на экран
Int() - преобразуем в тип int (буквы нельзя)
Str() - преобразуем в тип str
Boolean - True/False
S = Input() кладем в s что-то введенное с клавы (до enter)
s = input('Everypody can see it, wow: ')

# - коммент
Format > comment/uncomment out region - в панели задач, оч круто

Непечатаемые символы

\n - конец строки
\t - tab

	
Двойные кавычки идут с двойными, одинарные с одинарными, но разницы нет
\” - экранируем кавычки, теперь они ничего не значат
\’ - экранируем кавычки, теперь они ничего не значат

Условные конструкции - надо уметь реагировать на данные
Деревья
If smth == true:
<
>
<=
>=
==
!=
If smth == true:
	print(a - b)
#tab = 4 spaces
elif a > b:
print('lol')
else:
	print(‘I hope you die’)
if you_love_me == true:
    if a == b:
        print(‘I love you’)
if a < b < c:
    print(‘agaga’)
    print(‘let me live’)

s1 = ‘me’
s2 = ‘you’
if s1 == s2:
    print(‘Yes’)
else:
    print(‘No’)

if a < c and a < b:
    print(c)
if a < c or b < a:
    print(b)

if not

instacod.es - красивая картинка кода

True    False
Word = ‘Маруся’
If word.startswith(‘М’):
    Print(‘M’)
If word.endswith(‘я’):
    Print(‘я’)
startswith()
endswith()


s = ‘I love homicides’
for letter in s:
    print(letter)
print(‘Done’)

цикл без тела - идиотизм
иногда после ин идут функции

range(10) выводит 0…9
range(2, 12) выводит 2…11

for digit in range(10):
    di = digit + 10
    print(digit)

for digit in range(10):
    if digit < 5:
        print(digit)


enumerate()
строки и тд нумеруется посимвольно с нуля => последний символ = len(s) - 1

print(s[0]) - печатаем первый символ. Индекс оф рэндж - слишком большое
s[-1] - последний символ, при длине 0 приведет к ошибке
for indx, letter in enumerate(s):
    print(s[indx], letter)

первая переменная всегда для индекса, вторая всегда для буквы. Если только одна - для буквы

for digit in range(len(s)):
    print (s[digit])
- для каждого слова в строке по числу

X = 5
While x < 10:
    Print(x)
    X+=1

X = 0
While x < len(s):
    Print(s[x])
    X+=1
    If s[x]==’o’
        Break

X+=1
If s[x]==’o’:
    continue
print(s[x])

continue - возвращает в начало цикла (не заново, а следующую)
pass - ничего не делает

списки массивы
s = [1, 2, 3, 4, 5, 6]
s1=[‘abc’,’de’,’fg’]
s0=[‘Masha is’, 18, ‘today’]
so + s1
s1 + s0
s1*5 пять раз повторится массив

s0[0]
s0[-1]
s0[1:-1]
s[::2] все нечетные
s[1::2] все четные
s[::] - весь
s[::-1] наоборот

s[1:-1] - задом наперед только четные

stri = ‘1234567’
stri[:1]
stri[:-1]
stri[-2] - второй элемент с конца

первый элт включается в срез, последний - нет
stri[1:5]
stri [::] - вся строка
stri[::2] - все нечетные
stri[1::2] - все четные 

stri[1:4:2] - от 1 к 4 с шагом 2
stri[4:1:-2] - от 4 к 1 с шагом -2


range работает так же
range (100, 2, -1) - в обратную сторону
шаг по умолчанию один

arr = [1, 2, 3, 4, 5]
arr[::2]
len(arr)

строки менять нельзя
arr[0] = 0
arr

добавляем в конец массива
arr.append(6) - прибавляем элемент
arr.insert(0, 3) перед элементом с индексом ноль ставится тройка, меняет индексы

удаление
del arr[0]  - занимает много памяти, меняет индексы
x = arr.pop(0)   -  убираем элт под номером ноль, индексы меняются

for I in arr:
    print(i)

for I in range(len(arr) -  перебираем индексы


массив массивов - двумерный массив
моделируем таблички

table = [[1, 2], [3, 4]]
for row in table:
    for column in row:
            print (column)
print(‘I’, ‘am’, ‘Masha’, sep = ‘ ’, end = ‘19’)

S.isdigit()	Состоит ли строка из цифр
S.isalpha()	Состоит ли строка из букв


Stri.split(‘,’) -  выводим строку через ,
Arr = Stri.split() - переводим строку в массив
Stri = ‘ ’.join(arr) - массив переводим в строку
Stri= ‘ ’ .join(arr) - массив переводим в строку, разделенную пробелами (?)

List - превращает строку в массив
A = list(s)
Join() - массив из строк

Python.org

Script.py - прога
1.txt - текст
F = open(“1.txt”) кладет в прогу объект под названием 1.txt (техническую инфу)

Путь к файлу абсолютный (из любой точки в пространстве - виндовз: имя диска \ юзер… символ экранирования, который бесит и отменяет все последующие знаки; либо ставим 2 обратных слэша, либо пишем прямой слэш, r’путь’ - сырой; на разных компах не работает) или относителный (f = open(“folder/1.txt”))

F = open(“1.txt”, ‘r’, encoding = “utf-8”)
Utf-8 третий питон по умолчанию пихает мне ее
Cp1251 виндовз по умолчанию пихает мне это

Notepad++ все про кодировки расскажет и покажет

F нельзя называть file
S = f.read()
Если нужен текст построчно, например:
A = f.read().split(‘\n’)
или
A = f.readlines()
Или
For line in f:
    Print(line) (print всегда переносит на новую строку, поэтому текст будет через пустую строку)
Без пустых строк:	
I = 0
For line in f:
    I += 1
Print(i)
Считаем слова
For line in f:		
    Words = line.split()
    I += len(words)
Print(i)

Закрываем файл (чтобы память не мурыжить):
f.close()
*считывать из открытого файла дважды нельзя

